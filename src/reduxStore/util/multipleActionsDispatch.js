/**
 * @summary A module providing support for dispatching an array of actions to a Redux store, with store subscribers being notified
 * only once after all the actions in the array are dispatched.
 *
 * Dispatching multiple actions to a Redux store by successive calls to <code>store.dispatch()</code> results in the
 * store's subscribers being notified after each dispatch. Thus, for example, store-connected React components
 * will re-render after each dispatch.
 * This module provides support for dispatching an array of actions to a store, resulting in each of the actions in the array
 * being dispatched (in order), and the store's subscribers being notified only once, after the last action was dispatched.
 * Note that, for convenience, falsy values in the array are ignored.
 *
 * @module reduxStore/util/multipleActionsDispatch
 *
 * @example <caption>How to set the store up</caption>
 * import {createStore, applyMiddleware, compose} from 'redux';
 * import {batchActionsMiddleware, enableReducersActionsBatching} from 'reduxStore/util/multipleActionsDispatch';
 * //
 * let reducer = ... // the Redux store reducer
 * let middleware = applyMiddleware(batchActionsMiddleware, ...);
 * let store = createStore(enableReducersActionsBatching(reducer), middleware);
 * //
 * // note: in case you have other enhancers of the store besides middleware (e.g., the devToolsExtension)
 * // you should combine the enhancers using the compose() method as in the following:
 * let store = createStore(enableReducersActionsBatching(reducer)
 *            , compose(middleware, window.devToolsExtension ? window.devToolsExtension() : f => f));
 *
 * @example <caption>How to dispatch multiple actions</caption>
 * store.dispatch([action1, action2, action3]);
 */

/*
 * The type of an action with a payload which is an array of actions.
 * Actions with this type are intercepted by the reducer wrapper method {@linkcode enableReducersActionsBatching}, and are
 * automatically generated by the redux middleware method {@linkcode batchActionsMiddleware} to wrap actions that are arrays.
 * Note that one <strong>should not</strong> explicitly create actions with this type.
 * @type {String}
 */
export const BATCH_ACTION_TYPE = '08D745BC-B1B7-46E4-9B7C-B95B9F23041D';

/**
 * A Redux middleware that intercepts actions which are arrays and re-dispatches them by wrapping the array
 * in an action with a special type ({@linkcode BATCH_ACTION_TYPE}) and a payload which is the array.
 * @param  {module:Redux.Store} store   the Redux store to apply this middleware to.
 * @return {function}       the middlware function to be passed to {@linkcode module:Redux.applyMiddleware()}.
 */
export let batchActionsMiddleware = (store) => (nextDispatch) => {
  return function (action) {
    if (Array.isArray(action)) {
      return nextDispatch({               //  wrap the recieved array in an action with type BATCH_ACTION_TYPE and pass it up the dispatch chain
        type: BATCH_ACTION_TYPE,
        actions: action
      });
    } else {      // action is not an array
      return nextDispatch(action);      // pass the action along the dispatch chain
    }
  };
};

/**
 * A method that wraps a Redux store reducer returning a reducer that intercepts actions of type {@linkcode BATCH_ACTION_TYPE}.
 * Such actions contain as payload an array of other actions, and this method applies the wrapped reducer
 * to each of the actions in the array (in order); other actions are simply passed to the wrapped reducer.
 *
 * @param  {function} storeReducer the reducer to wrap.
 * @return {function}              a new reducer that intercepts actions of type {@linkcode BATCH_ACTION_TYPE}.
 */
export function enableReducersActionsBatching (storeReducer) {
  return function batchingReducer (state, action) {
    if (action.type === BATCH_ACTION_TYPE) {
      // update store to be the result of applying storeReducer to every action in the array action.actions
      for (let subAction of action.actions) {
        if (subAction) {        // ignore falsy actions
          state = storeReducer(state, subAction);
        }
      }
      return state;
    } else {
      return storeReducer(state, action);       // simply call the wrapped storeReducer
    }
  };
}
